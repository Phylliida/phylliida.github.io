<html>
<head>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script>


// one way wall that lets things through vertically (or horizontally) but not other way around


var globalDrawConfig = {
    pixelsPerWidth: 20,
    pixelsPerHeight: 20,
    outlineWidth: 0.5,
    renderParams: {
        worldLeftX: 0,
        worldTopY: 0,
        sideMenuLeftX: 0,
        sideMenuTopY: 0
    }
};

globalDrawConfig.paddingX = 50;
globalDrawConfig.paddingY = 100;
globalDrawConfig.sideMenuPaddingX = globalDrawConfig.pixelsPerWidth;
globalDrawConfig.sideMenuPaddingY = globalDrawConfig.pixelsPerHeight*2;
globalDrawConfig.sideMenuPaddingSize = 20;

var animTicks = 128;
var updateTicks = 16;


var worldGlobal;

var objectDragging = null;
var copying = false;

        
// From https://stackoverflow.com/a/2259502/2924421
var rotatePoint = function(point, rotateAround, angleRadians)
{
  var s = Math.sin(angleRadians);
  var c = Math.cos(angleRadians);

  // translate point back to origin:
  var shiftedX = point.x - rotateAround.x;
  var shiftedY = point.y - rotateAround.y;

  // rotate point
  var xnew = shiftedX * c - shiftedY * s;
  var ynew = shiftedX * s + shiftedY * c;

  // translate point back:
  var pointX = xnew + rotateAround.x;
  var pointY = ynew + rotateAround.y;
  return {x: pointX, y: pointY};
};

var pts = function(point){
    return "(" + point.x + "," + point.y + ")";
};


var isMovable = function(item){
    return item == circle;
};

var isSolid = function(item) {
    return item == solid || item == fan || item == filledCircle || item == leftfan || item == rightfan || item == upfan || item == downfan;
};

var fan = {
  label: "fan",
  update : function(world, tick, posX, posY) {
    for (var x = posX+1; x < world.width; x++) {
        var item = world.data[x][posY];
        if (isMovable(item)) {
            world.nextPos[x][posY].x += 1;
        } else if (isSolid(item)) {
            break;
        }
    }
    for (var y = posY+1; y < world.height; y++) {
        var item = world.data[posX][y];
        if (isMovable(item)) {
            world.nextPos[posX][y].y += 1;
        } else if (isSolid(item)) {
            break;
        }
    }
    for (var x = posX-1; x >= 0; x--) {
        var item = world.data[x][posY];
        if (isMovable(item)) {
            world.nextPos[x][posY].x -= 1;
        } else if (isSolid(item)) {
            break;
        }
    }
    for (var y = posY-1; y >= 0; y--) {
        var item = world.data[posX][y];
        if (isMovable(item)) {
            world.nextPos[posX][y].y -= 1;
        } else if (isSolid(item)) {
            break;
        }
    }
  },
  draw : function(ctx, tick, leftX, topY, rightX, bottomY, drawConfig) {
    var xMid = (leftX + rightX)/2.0;
    var yMid = (topY + bottomY)/2.0;
    var rotateRadians = (tick % Math.round(animTicks/2))/(0.0+animTicks/2)*2*Math.PI;
    var center = {x: xMid, y: yMid};
    var fanOffset = 5;
    var topFanPoint = rotatePoint({x: xMid, y: topY+fanOffset}, center, rotateRadians);
    var leftFanPoint = rotatePoint({x: leftX+fanOffset, y: yMid}, center, rotateRadians);
    var bottomFanPoint = rotatePoint({x: xMid, y: bottomY-fanOffset}, center, rotateRadians);
    var rightFanPoint = rotatePoint({x: rightX-fanOffset, y: yMid}, center, rotateRadians);
    //console.log(pts(topFanPoint) + " " + pts(leftFanPoint) + " " + pts(bottomFanPoint) + " " + pts(rightFanPoint));
    ctx.lineWidth = 3;
    drawLine(ctx, topFanPoint.x, topFanPoint.y, bottomFanPoint.x, bottomFanPoint.y);
    drawLine(ctx, leftFanPoint.x, leftFanPoint.y, rightFanPoint.x, rightFanPoint.y);
  }
};

var upfan = {
  label: "upfan",
  update : function(world, tick, posX, posY) {
    
    var canBlow = true;
    if (posY+1 < world.height) {
        if (world.data[posX][posY+1] == circle) {
            canBlow = false;
        }
    }
    if (canBlow)
    {
        for (var y = posY-1; y >= 0; y--) {
            var item = world.data[posX][y];
            if (isMovable(item)) {
                world.nextPos[posX][y].y -= 1;
            } else if (isSolid(item)) {
                break;
            }
        }
    }
  },
  draw : function(ctx, tick, leftX, topY, rightX, bottomY, drawConfig) {
    var xMid = (leftX + rightX)/2.0;
    var yMid = (topY + bottomY)/2.0;
    
    var canBlow = true;
    var worldPos = mouseCoordsToWorldCoords((leftX+rightX)/2, (topY+bottomY)/2, drawConfig);
    if (worldPosIsInWorld(worldGlobal, worldPos)) {
        if (worldPos.y+1 < worldGlobal.height) {
            if (worldGlobal.data[worldPos.x][worldPos.y+1] == circle) {
                canBlow = false;
            }
        }
    }
    var rotateRadians = (tick % Math.round(animTicks/2))/(0.0+animTicks/2)*2*Math.PI;
    if (!canBlow) {
        rotateRadians = 0;
    }
    var center = {x: xMid, y: yMid};
    var fanOffset = 5;
    var topFanPoint = rotatePoint({x: xMid, y: topY+fanOffset}, center, rotateRadians);
    var leftFanPoint = rotatePoint({x: leftX+fanOffset, y: yMid}, center, rotateRadians);
    var bottomFanPoint = rotatePoint({x: xMid, y: bottomY-fanOffset}, center, rotateRadians);
    var rightFanPoint = rotatePoint({x: rightX-fanOffset, y: yMid}, center, rotateRadians);
    //console.log(pts(topFanPoint) + " " + pts(leftFanPoint) + " " + pts(bottomFanPoint) + " " + pts(rightFanPoint));
    ctx.lineWidth = 3;
    drawLine(ctx, topFanPoint.x, topFanPoint.y, bottomFanPoint.x, bottomFanPoint.y);
    drawLine(ctx, leftFanPoint.x, leftFanPoint.y, rightFanPoint.x, rightFanPoint.y);
    
    ctx.lineWidth = 1;
    
    var boundaryOffset = fanOffset-2;
    // Top
    //drawLine(ctx, leftX+boundaryOffset, topY+boundaryOffset, rightX-boundaryOffset, topY+boundaryOffset);
    // Left
    drawLine(ctx, leftX+boundaryOffset, topY+boundaryOffset, leftX+boundaryOffset, bottomY-boundaryOffset);
    // Right
    drawLine(ctx, rightX-boundaryOffset, topY+boundaryOffset, rightX-boundaryOffset, bottomY-boundaryOffset);
    // Bottom
    drawLine(ctx, leftX+boundaryOffset, bottomY-boundaryOffset, rightX-boundaryOffset, bottomY-boundaryOffset);
  }
};

var leftfan = {
  label: "leftfan",
  update : function(world, tick, posX, posY) {
  
    var canBlow = true;
    if (posX+1 < world.width) {
        if (world.data[posX+1][posY] == circle) {
            canBlow = false;
        }
    }
    if (canBlow)
    {
        for (var x = posX-1; x >= 0; x--) {
            var item = world.data[x][posY];
            if (isMovable(item)) {
                world.nextPos[x][posY].x -= 1;
            } else if (isSolid(item)) {
                break;
            }
        }
    }
  },
  draw : function(ctx, tick, leftX, topY, rightX, bottomY, drawConfig) {
    var xMid = (leftX + rightX)/2.0;
    var yMid = (topY + bottomY)/2.0;
    var canBlow = true;
    var worldPos = mouseCoordsToWorldCoords((leftX+rightX)/2, (topY+bottomY)/2, drawConfig);
    if (worldPosIsInWorld(worldGlobal, worldPos)) {
        if (worldPos.x+1 < worldGlobal.width) {
            if (worldGlobal.data[worldPos.x+1][worldPos.y] == circle) {
                canBlow = false;
            }
        }
    }
    var rotateRadians = (tick % Math.round(animTicks/2))/(0.0+animTicks/2)*2*Math.PI;
    if (!canBlow) {
        rotateRadians = 0;
    }
    var center = {x: xMid, y: yMid};
    var fanOffset = 5;
    var topFanPoint = rotatePoint({x: xMid, y: topY+fanOffset}, center, rotateRadians);
    var leftFanPoint = rotatePoint({x: leftX+fanOffset, y: yMid}, center, rotateRadians);
    var bottomFanPoint = rotatePoint({x: xMid, y: bottomY-fanOffset}, center, rotateRadians);
    var rightFanPoint = rotatePoint({x: rightX-fanOffset, y: yMid}, center, rotateRadians);
    //console.log(pts(topFanPoint) + " " + pts(leftFanPoint) + " " + pts(bottomFanPoint) + " " + pts(rightFanPoint));
    ctx.lineWidth = 3;
    drawLine(ctx, topFanPoint.x, topFanPoint.y, bottomFanPoint.x, bottomFanPoint.y);
    drawLine(ctx, leftFanPoint.x, leftFanPoint.y, rightFanPoint.x, rightFanPoint.y);
    
    ctx.lineWidth = 1;
    
    var boundaryOffset = fanOffset-2;
    // Top
    drawLine(ctx, leftX+boundaryOffset, topY+boundaryOffset, rightX-boundaryOffset, topY+boundaryOffset);
    // Left
    //drawLine(ctx, leftX+boundaryOffset, topY+boundaryOffset, leftX+boundaryOffset, bottomY-boundaryOffset);
    // Right
    drawLine(ctx, rightX-boundaryOffset, topY+boundaryOffset, rightX-boundaryOffset, bottomY-boundaryOffset);
    // Bottom
    drawLine(ctx, leftX+boundaryOffset, bottomY-boundaryOffset, rightX-boundaryOffset, bottomY-boundaryOffset);
  }
};
var rightfan = {
  label: "rightfan",
  update : function(world, tick, posX, posY) {
  
    var canBlow = true;
    if (posX-1 >= 0) {
        if (world.data[posX-1][posY] == circle) {
            canBlow = false;
        }
    }
    if (canBlow) {
        
        for (var x = posX+1; x < world.width; x++) {
            var item = world.data[x][posY];
            if (isMovable(item)) {
                world.nextPos[x][posY].x += 1;
            } else if (isSolid(item)) {
                break;
            }
        }
    }
  },
  draw : function(ctx, tick, leftX, topY, rightX, bottomY, drawConfig) {
    var xMid = (leftX + rightX)/2.0;
    var yMid = (topY + bottomY)/2.0;
    
    var canBlow = true;
    var worldPos = mouseCoordsToWorldCoords((leftX+rightX)/2, (topY+bottomY)/2, drawConfig);
    if (worldPosIsInWorld(worldGlobal, worldPos)) {
        if (worldPos.x-1 >= 0) {
            if (worldGlobal.data[worldPos.x-1][worldPos.y] == circle) {
                canBlow = false;
            }
        }
    }
    var rotateRadians = (tick % Math.round(animTicks/2))/(0.0+animTicks/2)*2*Math.PI;
    if (!canBlow){
        rotateRadians = 0;
    }
    var center = {x: xMid, y: yMid};
    var fanOffset = 5;
    var topFanPoint = rotatePoint({x: xMid, y: topY+fanOffset}, center, rotateRadians);
    var leftFanPoint = rotatePoint({x: leftX+fanOffset, y: yMid}, center, rotateRadians);
    var bottomFanPoint = rotatePoint({x: xMid, y: bottomY-fanOffset}, center, rotateRadians);
    var rightFanPoint = rotatePoint({x: rightX-fanOffset, y: yMid}, center, rotateRadians);
    //console.log(pts(topFanPoint) + " " + pts(leftFanPoint) + " " + pts(bottomFanPoint) + " " + pts(rightFanPoint));
    ctx.lineWidth = 3;
    drawLine(ctx, topFanPoint.x, topFanPoint.y, bottomFanPoint.x, bottomFanPoint.y);
    drawLine(ctx, leftFanPoint.x, leftFanPoint.y, rightFanPoint.x, rightFanPoint.y);
    
    ctx.lineWidth = 1;
    
    var boundaryOffset = fanOffset-2;
    // Top
    drawLine(ctx, leftX+boundaryOffset, topY+boundaryOffset, rightX-boundaryOffset, topY+boundaryOffset);
    // Left
    drawLine(ctx, leftX+boundaryOffset, topY+boundaryOffset, leftX+boundaryOffset, bottomY-boundaryOffset);
    // Right
    //drawLine(ctx, rightX-boundaryOffset, topY+boundaryOffset, rightX-boundaryOffset, bottomY-boundaryOffset);
    // Bottom
    drawLine(ctx, leftX+boundaryOffset, bottomY-boundaryOffset, rightX-boundaryOffset, bottomY-boundaryOffset);
  }
};
var downfan = {
  label: "downfan",
  update : function(world, tick, posX, posY) {
  
  
    var canBlow = true;
    if (posY-1 >= 0) {
        if (world.data[posX][posY-1] == circle) {
            canBlow = false;
        }
    }
    if (canBlow)
    {
        for (var y = posY+1; y < world.height; y++) {
            var item = world.data[posX][y];
            if (isMovable(item)) {
                world.nextPos[posX][y].y += 1;
            } else if (isSolid(item)) {
                break;
            }
        }
    }
  },
  draw : function(ctx, tick, leftX, topY, rightX, bottomY, drawConfig) {
    var xMid = (leftX + rightX)/2.0;
    var yMid = (topY + bottomY)/2.0;
    
    var canBlow = true;
    var worldPos = mouseCoordsToWorldCoords((leftX+rightX)/2, (topY+bottomY)/2, drawConfig);
    if (worldPosIsInWorld(worldGlobal, worldPos)) {
        if (worldPos.y-1 >= 0) {
            if (worldGlobal.data[worldPos.x][worldPos.y-1] == circle) {
                canBlow = false;
            }
        }
    }
    var rotateRadians = (tick % Math.round(animTicks/2))/(0.0+animTicks/2)*2*Math.PI;
    if (!canBlow) {
        rotateRadians = 0;
    }
    var center = {x: xMid, y: yMid};
    var fanOffset = 5;
    var topFanPoint = rotatePoint({x: xMid, y: topY+fanOffset}, center, rotateRadians);
    var leftFanPoint = rotatePoint({x: leftX+fanOffset, y: yMid}, center, rotateRadians);
    var bottomFanPoint = rotatePoint({x: xMid, y: bottomY-fanOffset}, center, rotateRadians);
    var rightFanPoint = rotatePoint({x: rightX-fanOffset, y: yMid}, center, rotateRadians);
    //console.log(pts(topFanPoint) + " " + pts(leftFanPoint) + " " + pts(bottomFanPoint) + " " + pts(rightFanPoint));
    ctx.lineWidth = 3;
    drawLine(ctx, topFanPoint.x, topFanPoint.y, bottomFanPoint.x, bottomFanPoint.y);
    drawLine(ctx, leftFanPoint.x, leftFanPoint.y, rightFanPoint.x, rightFanPoint.y);
    
    ctx.lineWidth = 1;
    
    var boundaryOffset = fanOffset-2;
    // Top
    drawLine(ctx, leftX+boundaryOffset, topY+boundaryOffset, rightX-boundaryOffset, topY+boundaryOffset);
    // Left
    drawLine(ctx, leftX+boundaryOffset, topY+boundaryOffset, leftX+boundaryOffset, bottomY-boundaryOffset);
    // Right
    drawLine(ctx, rightX-boundaryOffset, topY+boundaryOffset, rightX-boundaryOffset, bottomY-boundaryOffset);
    // Bottom
    //drawLine(ctx, leftX+boundaryOffset, bottomY-boundaryOffset, rightX-boundaryOffset, bottomY-boundaryOffset);
  }
};
var empty = {
  label: "empty",
  update : function(world, tick, posX, posY) {
  },
  draw : function(ctx, tick, leftX, topY, rightX, bottomY, drawConfig) {
  }
};


var solid = {
  label: "solid",
  update : function(world, tick, posX, posY) {
    if (posX > 0) {
        
    }
  },
  draw : function(ctx, tick, leftX, topY, rightX, bottomY, drawConfig) {
    ctx.fillRect(leftX+drawConfig.outlineWidth,topY+drawConfig.outlineWidth,rightX-leftX-drawConfig.outlineWidth*2+1, bottomY-topY-drawConfig.outlineWidth*2+1); // x y width height
  }
};

var drawLine = function(ctx, startX, startY, endX, endY) {
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();
};

var circle = {
  label: "circle",
  update : function(world, tick, posX, posY) {
    
  },
  draw : function(ctx, tick, leftX, topY, rightX, bottomY, drawConfig) {
    ctx.beginPath();
    ctx.arc((leftX+rightX)/2, (topY+bottomY)/2, (rightX-leftX+1)/2-4, 0, 2 * Math.PI);
    ctx.stroke();
  }
};

var filledCircle = {
  label: "filledCircle",
  update : function(world, tick, posX, posY) {
    
  },
  draw : function(ctx, tick, leftX, topY, rightX, bottomY, drawConfig) {
    ctx.beginPath();
    ctx.arc((leftX+rightX)/2, (topY+bottomY)/2, (rightX-leftX+1)/2-4, 0, 2 * Math.PI);
    ctx.fill();
  }
};



var menu = {
    items: [
        fan,
        upfan,
        leftfan,
        rightfan,
        downfan,
        //empty,
        //solid,
        circle,
        filledCircle
    ],
    colliders: [],
    draw: function(ctx, ticks, renderParams, drawConfig) {
        var menuLeftX = renderParams.sideMenuLeftX;
        var menuTopY = renderParams.sideMenuTopY;
        var maxMenuY = renderParams.maxMenuY;
        var currentItemY = menuTopY;
        var nextRowX = menuLeftX;
        var curRowX = menuLeftX;
        var bottomMenuY = menuTopY;
        var rightMenuX = menuLeftX;
        for (var i = 0; i < this.items.length; i++){
            ctx.strokeStyle = "black";
            ctx.fillStyle = "black";
            ctx.lineWidth = 1;
            var leftX = curRowX;
            var topY = currentItemY;
            var rightX = leftX+drawConfig.pixelsPerWidth-1;
            var bottomY = topY+drawConfig.pixelsPerHeight-1;
            this.items[i].draw(ctx, ticks, leftX, topY, rightX, bottomY, drawConfig);
            ctx.strokeStyle = "gray";
            ctx.fillStyle = "gray";
            ctx.lineWidth = drawConfig.outlineWidth*2;
            ctx.beginPath();
            var boxWidth = rightX -leftX+1;
            var boxHeight = bottomY-topY+1;
            if (this.items[i].data != null) {
                boxWidth = boxWidth*this.items[i].data.length;
                boxHeight = boxHeight*this.items[i].data[0].length;
            }
            
            bottomMenuY = Math.max(topY+boxHeight, bottomMenuY);
            rightMenuX = Math.max(leftX+boxWidth, rightMenuX);
            this.colliders.push({leftX:leftX, topY:topY, rightX:leftX+boxWidth, bottomY:topY+boxHeight, item:this.items[i]}); 
            nextRowX = Math.max(nextRowX, curRowX+boxWidth+drawConfig.pixelsPerWidth);
            currentItemY += boxHeight+drawConfig.pixelsPerHeight;
            if (currentItemY > maxMenuY) {
                currentItemY = menuTopY;
                curRowX = nextRowX;
            }
            ctx.rect(leftX, topY, boxWidth, boxHeight);
            ctx.stroke();
        }
        return {leftX: menuLeftX, topY: menuTopY, rightX: rightMenuX, bottomY: bottomMenuY}
    },

    computeRenderParams: function(ctx, ticks, world, drawConfig) {
        var menuSizes = this.draw(ctx, ticks, drawConfig.renderParams, drawConfig);
        params = {};
        
        params.sideMenuWidth = menuSizes.rightX-menuSizes.leftX+1;
        params.sideMenuHeight = menuSizes.bottomY-menuSizes.topY+1;

        params.sideOffset = drawConfig.paddingX+drawConfig.sideMenuPaddingX+params.sideMenuWidth+drawConfig.sideMenuPaddingX;
        params.upOffset = drawConfig.paddingY;

        params.canvasWidth = drawConfig.paddingX+drawConfig.sideMenuPaddingX+params.sideMenuWidth+drawConfig.sideMenuPaddingX+drawConfig.pixelsPerWidth*world.width+drawConfig.paddingX;
        params.canvasHeight = Math.max(
            drawConfig.paddingY+drawConfig.pixelsPerHeight*world.height+drawConfig.paddingY,// height of world
            drawConfig.paddingY+drawConfig.sideMenuPaddingY+params.sideMenuHeight+drawConfig.sideMenuPaddingY+drawConfig.paddingY // height of side menu
        )

        params.sideMenuLeftX = drawConfig.paddingX+drawConfig.sideMenuPaddingX;
        params.sideMenuTopY = drawConfig.paddingY+drawConfig.sideMenuPaddingY;

        params.worldLeftX = params.sideOffset;
        params.worldTopY = params.upOffset;
        params.maxMenuY = world.height*drawConfig.pixelsPerHeight+params.worldTopY;
        return params;
    }
};


var allItems = [
    fan,
    upfan,
    leftfan,
    rightfan,
    downfan,
    empty,
    solid,
    circle,
    filledCircle
];



var mouseCoordsToWorldCoords = function(x, y, drawConfig) {
      var worldX = Math.floor((x-drawConfig.renderParams.worldLeftX)/drawConfig.pixelsPerWidth);
      var worldY = Math.floor((y-drawConfig.renderParams.worldTopY)/drawConfig.pixelsPerHeight);
      return {x: worldX, y: worldY}
};

var worldPosIsInWorld = function(world, worldPos) {
    return worldPos.x >= 0 && worldPos.x < world.width && worldPos.y >= 0 && worldPos.y < world.height;
};

var createCopyItemFromData = function(copyData) {

    var copyItem = {
      label: "copyItem",
      data: copyData,
      update : function(world, tick, posX, posY) {
        
      },
      draw : function(ctx, tick, leftX, topY, rightX, bottomY, drawConfig) {
        for (var x = 0; x < this.data.length; x++) {
            for (var y = 0; y < this.data[0].length; y++) {
                var xOffset = x*drawConfig.pixelsPerWidth;
                var yOffset = y*drawConfig.pixelsPerHeight;
                this.data[x][y].draw(ctx, tick, leftX+xOffset, topY+yOffset, rightX+xOffset, bottomY+yOffset, drawConfig);
            }
        }
      },
      canPlace : function(world, posX, posY) {
        for (var x = 0; x < this.data.length; x++) {
            for (var y = 0; y < this.data[0].length; y++){
                var localWorldPos = {x: x+posX, y: y+posY};
                if (worldPosIsInWorld(world, localWorldPos)){
                    var worldObject = world.data[localWorldPos.x][localWorldPos.y];
                    var copyObject = this.data[x][y];
                    // if either is empty, we match
                    // otherwise, make sure we match
                    if (worldObject != empty && copyObject != empty && 
                        worldObject != copyObject) {
                        return false;
                    }
                }
                else
                {
                    return false;
                }
            }
        }
        return true;
      }
    };
    
    return copyItem;
};

// For converting copy item to a form we can store in local storage
// only saves labels in the array so then we can make sure to use up to date item code
var copyItemToLabelData = function(copyItem) {
    var labelData = [];
    for (var x = 0; x < copyItem.data.length; x++) {
        var row = [];
        for (var y = 0; y < copyItem.data[x].length; y++) {
            row.push(copyItem.data[x][y].label);
        }
        labelData.push(row);
    }
    return labelData;
}

// From stuff saved in local storage
var createCopyItemFromLabelData = function(data) {
    var copyData = [];
    for (var x = 0; x < data.length; x++) {
        var row = [];
        for (var y = 0; y < data[x].length; y++) {
            var found = false;
            for (var i = 0; i < allItems.length; i++) {
                if (allItems[i].label == data[x][y]){
                    row.push(allItems[i]);
                    found = true;
                    break;
                }
            }
            if (!found) {
                row.push(empty);
                console.log("could not find copy data with label: " + data[x][y]);
            }
        }
        copyData.push(row);
    }
    
    return createCopyItemFromData(copyData);
};

var createCopyItem = function(world, startX, startY, endX, endY){
    var nonEmptyMinX = endX;
    var nonEmptyMaxX = startX;
    var nonEmptyMinY = endY;
    var nonEmptyMaxY = startY;
    
    // shrink down to just the non-empty stuff
    var hadAtLeastOneNonEmpty = false;
    for (var x = startX; x <= endX; x++) {
        for (var y = startY; y <= endY; y++) {
            if (world.data[x][y] != empty) {
                hadAtLeastOneNonEmpty = true;
                nonEmptyMinX = Math.min(nonEmptyMinX, x);
                nonEmptyMaxX = Math.max(nonEmptyMaxX, x);
                nonEmptyMinY = Math.min(nonEmptyMinY, y);
                nonEmptyMaxY = Math.max(nonEmptyMaxY, y);
            }
        }
    }
    // return null, it's empty
    if (!hadAtLeastOneNonEmpty) {
        return null;
    }
    // make only contain items
    else {
        startX = nonEmptyMinX;
        startY = nonEmptyMinY;
        endX = nonEmptyMaxX;
        endY = nonEmptyMaxY;
    }
    
    
    var copyData = [];
    for (var x = startX; x <= endX; x++) {
        var row = [];
        for (var y = startY; y <= endY; y++) {
            row.push(world.data[x][y]);
        }
        copyData.push(row);
    }
    
    return createCopyItemFromData(copyData);
};

var drawGrid = function(ctx, leftX, topY, cellWidth, cellHeight, nCellsX, nCellsY, outlineWidth) {
    var rightX = leftX+nCellsX*cellWidth;
    var bottomY = topY+nCellsY*cellHeight;
    
    var grayColor = '#444444';
    ctx.strokeStyle = grayColor;
    ctx.fillStyle = grayColor;
    ctx.lineWidth = 1;
    // Horizontal lines (need +1 because have one at top of every cell, then an additional line at the bottom of the last row)
    for (var y = 0; y < nCellsY+1; y++) {
        var yPos = topY+y*cellHeight;
        drawLine(ctx, leftX-outlineWidth, yPos, rightX+outlineWidth, yPos); // - and + outline width is so the corners line up
    }
    // Vertical lines (need +1 because have one at left of every cell, then an additional line at the right of the last column)
    for (var x = 0; x < nCellsX+1; x++) {
        var xPos = leftX+x*cellWidth;
        drawLine(ctx, xPos, topY-outlineWidth, xPos, bottomY+outlineWidth);
    }
    return {leftX: leftX-outlineWidth, topY: topY-outlineWidth, rightX: rightX+outlineWidth, bottomY: bottomY+outlineWidth};
};

var copyItems = [];
try {
    copyItems = JSON.parse(window.localStorage.getItem("copyItems"));
} catch(e) {
    console.log("failed to parse saved copy items, resetting");
    copyItems = [];
}

var updateCopyItems = function() {
    if (copyItems != null && Array.isArray(copyItems)) {
        for (var i = 0; i < copyItems.length; i++){ 
            menu.items.push(createCopyItemFromLabelData(copyItems[i]));
        }
    }
    else {
        copyItems = [];
        window.localStorage.setItem("copyItems", JSON.stringify(copyItems));
    }
};

updateCopyItems();


var drop = function(e) {
    ignoreDrag(e);
    var dt = e.originalEvent.dataTransfer;
      var files = dt.files;

      if(dt.files.length > 0){
        var file = dt.files[0];
        const reader = new FileReader();
        reader.onload = function(fileLoadedEvent){
          var textFromFileLoaded = fileLoadedEvent.target.result;
          var resultJson = JSON.parse(textFromFileLoaded);
          console.log(JSON.stringify(resultJson));
          for (var i = 0; i < resultJson.length; i++) {
            menu.items.push(createCopyItemFromLabelData(resultJson[i]));
            copyItems.push(resultJson[i]);
          }
            window.localStorage.setItem("copyItems", JSON.stringify(copyItems));
        };
        console.log(file);
        reader.readAsText(file);
      }
      
    //var data = event.originalEvent.dataTransfer.getData("text/plain");
    ////console.log(data);
    //copyItems = JSON.parse(data);
    //updateCopyItems();
    return false;
};

// From https://stackoverflow.com/a/12325686/2924421
function ignoreDrag(e) {
  e.originalEvent.stopPropagation();
  e.originalEvent.preventDefault();
}


var copyData = function(data) {
    var copy = [];
    for (var x = 0; x < data.length; x++) {
        var row = []
        for (var y = 0; y < data[x].length; y++){
            row.push(data[x][y]);
        }
        copy.push(row);
    }
    return copy;
};




var createWorld = function(worldWidth, worldHeight, ctx) {
    var world = {
        width: worldWidth,
        height: worldHeight,
        ctx: ctx,
        history: [],
        redoBuffer: [],
        setAtPos: function(x, y, value) {
            this.data[x][y] = value;
            this.nextData[x][y] = value;
            this.update(0, false);
        },
        
        undo: function(){
            if (this.history.length > 1) {
                // Thing at very top is current world, so we need to go back two
                this.data = copyData(this.history[this.history.length-2]);
                this.redoBuffer.push(this.history[this.history.length-1]);
                this.history.splice(-1, 1);
                this.update(0, false);
            }
        },
    
        redo: function() {
            if (this.redoBuffer.length > 0) {
                this.data = copyData(this.redoBuffer[this.redoBuffer.length-1]);
                this.history.push(copyData(this.data));
                this.redoBuffer.splice(-1, 1);
                this.update(0, false);
            }
        },
    
    
        removeMoveToOption: function(moveOption) {
            var options = this.nextPos[moveOption.fromX][moveOption.fromY].placesCanMaybeStillGoTo;
            var index = -1;
            for (var i = 0; i < options.length; i++) {
                if (options[i].x == moveOption.toX && options[i].y == moveOption.toY) {
                    index = i;
                    break;
                }
            }
            if (index == -1) {
                // This is okay, and can happen if we try to trickle stuck, remove a position, but there's an alternate position still available
                // Then later when we trickle stuck again, we will try and remove it again (but it's already removed), however now there is no more alternate positions
                // So stuck will actually be correctly trickled
            }
            else {
                // remove that option
                options.splice(index, 1);
            }
        },
        
        isHighestPriorityOption: function(moveOption){
            var options = this.nextPos[moveOption.fromX][moveOption.fromY].placesCanMaybeStillGoTo;
            for (var i = 0; i < options.length; i++) {
                if (options[i].priority > moveOption.priority) {
                    return false;
                }
            }
            return true;
        },
            
        
        // Recursively send stuck upstream
        // Everyone keeps track of the number of places they want to go to, so once those reach zero they are stuck
        trickleStuck: function(positionsToTrickle) {
            if (positionsToTrickle.length == 0) {
                return;
            }
            // Do it recursively upstream
            var peopleToProcess = [];
            for (var i = 0; i < positionsToTrickle.length; i++) {
                peopleToProcess.push(positionsToTrickle[i]);
            }
            while (peopleToProcess.length > 0) {
                var top = peopleToProcess.pop();
                // if it doesn't know that it is stuck, tell it it's stuck and append those that want to go there to the processed list
                if (this.nextPos[top.fromX][top.fromY].winnerGoesHere == null) {
                    // We lose (top.toX, top.toY) as a place we can go
                    this.removeMoveToOption(top);
                    // We we are out of places we can go to, trickle stuck to those coming into us as well
                    if (this.nextPos[top.fromX][top.fromY].placesCanMaybeStillGoTo.length == 0) {
                        this.nextPos[top.fromX][top.fromY].winnerGoesHere = {x: top.fromX, y: top.fromY};
                        this.nextPos[top.fromX][top.fromY].whereImGoing = {x: top.fromX, y: top.fromY};
                        for (var i = 0; i < this.nextPos[top.fromX][top.fromY].whoWantsToGoHere.length; i++) {
                            peopleToProcess.push(this.nextPos[top.fromX][top.fromY].whoWantsToGoHere[i]);
                        }
                        this.nextPos[top.fromX][top.fromY].whoWantsToGoHere = [];
                    }
                }
            }
        },
        
        // Recursively send "you can move here" upstream
        trickleCanMove: function(positionsToTrickle) {
            var changed = false;
            if (positionsToTrickle.length == 0) {
                return changed;
            }
            // Do it recursively upstream
            var peopleToProcess = [];
            for (var i = 0; i < positionsToTrickle.length; i++) {
                peopleToProcess.push(positionsToTrickle[i]);
            }
            while (peopleToProcess.length > 0) {
                var top = peopleToProcess.pop();
                //console.log("trickle can move " + top.x + "," + top.y);
                var curWhoWantsToGoHere = this.nextPos[top.x][top.y].whoWantsToGoHere;
                //console.log("processing " + top.x + "," + top.y + " with who want to go here of len " + curWhoWantsToGoHere.length);
                // If we haven't told it that things can move here and there are people that want to go here
                if (this.nextPos[top.x][top.y].winnerGoesHere == null && curWhoWantsToGoHere.length > 0) {
                    // TODO: Better precedence choosing
                    var highestPriority = -1000000;
                    var highestItem = null;
                    var highestIndex = 0;
                    for (var i = 0; i < curWhoWantsToGoHere.length; i++) {
                        if (this.nextPos[curWhoWantsToGoHere[i].fromX][curWhoWantsToGoHere[i].fromY].whereImGoing == null && // If that doesn't have an assigned place to go yet
                            this.isHighestPriorityOption(curWhoWantsToGoHere[i]) && // Only consider it if it's highest priority of the places that thing can go
                            curWhoWantsToGoHere[i].priority > highestPriority) { // Move the one with the highest priority
                            highestItem = curWhoWantsToGoHere[i];
                            highestPriority = highestItem.priority;
                            highestIndex = i;
                        }
                    }
                    //console.log("curWhoWantsToGoHere:" + JSON.stringify(curWhoWantsToGoHere));
                    var chosenOne = highestItem;
                    // If someone can move here, select them
                    if (chosenOne != null) {
                    
                        //console.log("trickle chosen one of " + JSON.stringify(this.nextPos[chosenOne.fromX][chosenOne.fromY]) + " when processing top of " + JSON.stringify(this.nextPos[top.x][top.y]));
                        
                        //console.log("trickle can move " + top.x + "," + top.y + " found chosen " + chosenOne.fromX + "," + chosenOne.fromY + "  " + chosenOne.toX + "," + chosenOne.toY);
                        curWhoWantsToGoHere.splice(highestIndex, 1);
                        //console.log("allowing " + chosenOne.x + "," + chosenOne.y + " to flow into " + top.x + "," + top.y);
                        this.nextPos[top.x][top.y].winnerGoesHere = {x: chosenOne.fromX, y: chosenOne.fromY};
                        this.nextPos[chosenOne.fromX][chosenOne.fromY].whereImGoing = {x: top.x, y: top.y};
                        
                        // append the thing that moved here into the list to trickle "you can move here" to that position
                        peopleToProcess.push({x: chosenOne.fromX, y: chosenOne.fromY});
                        
                        if (curWhoWantsToGoHere.length > 0){
                            //console.log("len " + curWhoWantsToGoHere.length);
                        }
                        // clear the list now that it is processed (we need to do this before the below line in case they recurse back to us)
                        this.nextPos[top.x][top.y].whoWantsToGoHere = [];
                        if (curWhoWantsToGoHere.length > 0){
                            //console.log("len after " + curWhoWantsToGoHere.length);
                        }
                        //console.log("top:" + top.x + "," + top.y + " " + highestPriority);
                        //console.log("trickle stuck:" + JSON.stringify(curWhoWantsToGoHere));
                        // Everyone that doesn't have alternate ways to go
                        this.trickleStuck(curWhoWantsToGoHere);
                        changed = true;
                    }
                    else
                    {
                        //console.log("trickle no chosen one " + JSON.stringify(this.nextPos[top.x][top.y]) + ", will wait for later");
                    }
                }
            }
            return changed;
        },
            
            
        update: function(ticks, updateFromLast) {
            this.update0(ticks, updateFromLast);
            this.update1(ticks, updateFromLast);
            this.update2(ticks, updateFromLast);
        },
        
        update0: function(ticks, updateFromLast) {
            if (this.readyToUpdate && updateFromLast){
                this.data = this.nextData;
                this.readyToUpdate = false;
            }
            
            
            // Reset next pos
            for (var x = 0; x < this.width; x++){
                for (var y = 0; y < this.height; y++){
                    this.nextPos[x][y].x = 0;
                    this.nextPos[x][y].y = 0;
                    this.nextPos[x][y].whoWantsToGoHere = [];
                    this.nextPos[x][y].winnerGoesHere = null;
                    this.nextPos[x][y].whereImGoing = null;
                    this.nextPos[x][y].placesCanMaybeStillGoTo = [];
                }
            }
            
            
            // Run update on all cells
            for (var x = 0; x < this.width; x++){
                for (var y = 0; y < this.height; y++){
                    this.data[x][y].update(this, ticks, x, y);
                }
            }
            
            // Set want to go to locations
            
            // Step 1
            // Start with things staying put, they get priority
            for (var x = 0; x < this.width; x++){
                for (var y = 0; y < this.height; y++){
                    var offsetX = this.nextPos[x][y].x;
                    var offsetY = this.nextPos[x][y].y;
                    if (offsetX == 0 && offsetY == 0 && this.data[x][y] != empty){ // empty doesn't count as being stuck
                        this.nextPos[x][y].winnerGoesHere = {x: x, y: y};
                        this.nextPos[x][y].whereImGoing = {x: x, y: y};
                        //console.log("stuck " + x + "," + y);
                    }
                }
            }
            
            // Step 2
            // Let places know that we want to move there
            // Or mark as stuck if the place we want to go is staying put from step 1
            for (var x = 0; x < this.width; x++){
                for (var y = 0; y < this.height; y++){
                    var offsetX = this.nextPos[x][y].x;
                    var offsetY = this.nextPos[x][y].y;
                    var thingMoving = this.data[x][y];
                    // No need to move empty, so only move non empty things that are moving
                    if (thingMoving != empty && (offsetX != 0 || offsetY != 0)){
                        var wantToGoX = x+offsetX;
                        var wantToGoY = y+offsetY;
                        var tryingToMove = false;
                        if (worldPosIsInWorld(this, {x: wantToGoX, y: wantToGoY}) &&
                            this.nextPos[wantToGoX][wantToGoY].winnerGoesHere == null) { // Make sure it isn't claimed by stationary
                            //console.log("I am " + x + "," + y + " and I want to go to " + wantToGoX + "," + wantToGoY);
                            var curPriority = 2;
                            if (offsetX == 0) { // vertical
                                curPriority = 1;
                            }
                            if (offsetY == 0) { // horizontal
                                curPriority = 0;
                            }
                            
                            this.nextPos[wantToGoX][wantToGoY].whoWantsToGoHere.push({fromX: x, fromY: y, toX: wantToGoX, toY: wantToGoY, priority: curPriority});
                            this.nextPos[x][y].placesCanMaybeStillGoTo.push({x: wantToGoX, y: wantToGoY, priority: curPriority});
                            tryingToMove = true;
                        }
                        // If diagnoal, also try horizontal
                        if (wantToGoX != x && wantToGoY != y) {
                            // If we are moving diagonally, also try moving horizontally
                            if (worldPosIsInWorld(this, {x: x, y: wantToGoY}) &&
                                this.nextPos[x][wantToGoY].winnerGoesHere == null) { // Make sure it isn't claimed by stationary
                                //console.log("I am " + x + "," + y + " and I want to go to " + wantToGoX + "," + wantToGoY);
                                // vertical
                                this.nextPos[x][wantToGoY].whoWantsToGoHere.push({fromX: x, fromY: y, toX: x, toY: wantToGoY, priority: 1});
                                this.nextPos[x][y].placesCanMaybeStillGoTo.push({x: x, y: wantToGoY, priority: 1});
                                tryingToMove = true;
                            }
                            if (worldPosIsInWorld(this, {x: wantToGoX, y: y}) &&
                                this.nextPos[wantToGoX][y].winnerGoesHere == null) { // Make sure it isn't claimed by stationary
                                //console.log("I am " + x + "," + y + " and I want to go to " + wantToGoX + "," + wantToGoY);
                                // horizontal
                                this.nextPos[wantToGoX][y].whoWantsToGoHere.push({fromX: x, fromY: y, toX: wantToGoX, toY: y, priority: 0});
                                this.nextPos[x][y].placesCanMaybeStillGoTo.push({x: wantToGoX, y: y, priority: 0});
                                tryingToMove = true;
                            }
                        }
                        
                        // We failed to move, stay put
                        if (!tryingToMove) {
                            this.nextPos[x][y].winnerGoesHere = {x: x, y: y};
                            this.nextPos[x][y].whereImGoing = {x: x, y: y};
                        }
                    }
                }
            }
        },
        
        update1: function(ticks, updateFromLast) {
            var changed = true;
            var iters = 0;
            // we need to do step 3 multiple times because of priority 
            while (changed) {
                changed = false;
                // Step 3: 
                // Trickle "stuck" and "can move" upstream
                for (var x = 0; x < this.width; x++){
                    for (var y = 0; y < this.height; y++){
                        var curWhoWantsToGoHere = this.nextPos[x][y].whoWantsToGoHere;
                        // if we are stuck and people want to go here, tell them no
                        if (this.nextPos[x][y].winnerGoesHere != null && curWhoWantsToGoHere.length > 0 && 
                            this.nextPos[x][y].winnerGoesHere.x == x && this.nextPos[x][y].winnerGoesHere.y == y) {
                            this.trickleStuck(curWhoWantsToGoHere);
                            // Clear array since we've processed them
                            this.nextPos[x][y].whoWantsToGoHere = [];
                            changed = true;
                        }
                        // If people want to go here and we are empty, they can come, trickle the okay up to them
                        else if(this.nextPos[x][y].winnerGoesHere == null && 
                            (this.data[x][y] == empty || this.nextPos[x][y].whereImGoing != null) && // empty (so people can go in here), or moving away already
                            curWhoWantsToGoHere.length > 0) { // previously had "can move" trickled to you, but had other alternatives to consider so waiting
                            //console.log("want to trickle in at position " + x + "," + y);
                            // sometimes it looks like it can move, but it needs to wait for other higher priority options to be considered first
                            // this returns true if it actually made a change
                            if(this.trickleCanMove([{x: x, y: y}])) { 
                                changed = true;
                            }
                        }
                        
                        // Otherwise, either:
                        //   no one wants to come here (we are fine, need no update)
                        //   people want to come here but we aren't empty, we need to wait for an okay by downstream to trickle to us
                    }
                }
                iters += 1;
                if (iters > 2) {
                    //console.log("completed iter " + iters);
                }
            }
        },
        
        update2: function(ticks, updateFromLast) {
            
            // Step 4: You can have cycles where everyone wants to go into someone else that also wants to move
            // Those cycles will not be in either case in the above
            
            // Step 5:
            // Actually move everyone
            var newWorldData = [];
            for (var x = 0; x < this.width; x++){
                var row = [];
                for (var y = 0; y < this.height; y++){
                    var curWinnerPos = this.nextPos[x][y].winnerGoesHere;
                    if (this.nextPos[x][y].whereImGoing == null && this.data[x][y] != empty) {
                        this.nextPos[x][y].whereImGoing = {x: x, y: y};
                        row.push(this.data[x][y]);
                        console.log("stuck gui " + JSON.stringify(this.nextPos[x][y]));
                        for (var i = 0; i < this.nextPos[x][y].placesCanMaybeStillGoTo.length; i++) {
                            var place = this.nextPos[x][y].placesCanMaybeStillGoTo[i];
                            console.log(i + " " + place.x + "," + place.y + " " + JSON.stringify(this.nextPos[place.x][place.y]));
                        }
                    }
                    else if (curWinnerPos == null) {
                        row.push(empty);
                    }
                    else {
                        row.push(this.data[curWinnerPos.x][curWinnerPos.y]);
                    }
                }
                newWorldData.push(row);
            }
            this.nextData = newWorldData;
            this.readyToUpdate = true;
        },
        
        draw: function(ctx, ticks, ticksUpdate, renderParams, drawConfig){
            
            var ctx = this.ctx;
            // extract render params
            var worldLeftX = renderParams.worldLeftX;
            var worldTopY = renderParams.worldTopY;
            var canvasWidth = renderParams.canvasWidth;
            var canvasHeight = renderParams.canvasHeight;
            
            
            // check if world changed (for storing history into undo buffer)
            var prevWorld = this.history[this.history.length-1];
            var worldChanged = false;
            for (var x = 0; x < this.width; x++){
                for (var y = 0; y < this.height; y++){
                    if (prevWorld[x][y] != this.data[x][y]) {
                        worldChanged = true;
                    }
                }
            }
            if (worldChanged) {
                //console.log("world changed");
                this.history.push(copyData(this.data));
                redoBuffer = [];
            }
            
            // set width and height
            ctx.canvas.height = canvasHeight;
            ctx.canvas.width = canvasWidth;
            
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0,0,canvasWidth, canvasHeight);
            var t0 = performance.now();
            
            //// Side Menu ////
            menu.draw(ctx, ticks, renderParams, drawConfig);
            
            
            //// Outline ////
            ctx.strokeStyle = "black";
            ctx.fillStyle = "black";
            ctx.lineWidth = drawConfig.outlineWidth*2;
            
            var worldBounds = drawGrid(ctx, worldLeftX, worldTopY, drawConfig.pixelsPerWidth, drawConfig.pixelsPerHeight, this.width, this.height, drawConfig.outlineWidth);
            
            ctx.strokeStyle = "black";
            ctx.fillStyle = "black";
            ctx.lineWidth = 1;
            
            //// Draw cells ////
            for (var i = 0; i < this.width; i++){
                for (var j = 0; j < this.height; j++){
                    var leftX = i*drawConfig.pixelsPerWidth+worldLeftX;
                    var topY = j*drawConfig.pixelsPerHeight+worldTopY;
                    ctx.lineWidth = 1;
                    var curWhereImGoing = this.nextPos[i][j].whereImGoing;
                    if (curWhereImGoing != null && 
                        (curWhereImGoing.x != i || curWhereImGoing.y != j)) {
                        if (this.paused) {
                            for (var k = 0; k < updateTicks; k++) {
                                var interpolateLeftX = curWhereImGoing.x*drawConfig.pixelsPerWidth+worldLeftX;
                                var interpolateTopY = curWhereImGoing.y*drawConfig.pixelsPerHeight+worldTopY;
                                
                                var amountInterpolate = k/updateTicks; // should be animTicks-1 if we want 0 to 1 but we actually want it to be smooth and finish on start frame so this is right
                                leftX = leftX*(1-amountInterpolate) + interpolateLeftX*amountInterpolate;
                                topY = topY*(1-amountInterpolate) + interpolateTopY*amountInterpolate;
                                var rightX = leftX+drawConfig.pixelsPerWidth-1;
                                var bottomY = topY+drawConfig.pixelsPerHeight-1;
                                this.data[i][j].draw(ctx, ticks, leftX, topY, rightX, bottomY, drawConfig);
                            }
                        }
                        else {
                            var interpolateLeftX = curWhereImGoing.x*drawConfig.pixelsPerWidth+worldLeftX;
                            var interpolateTopY = curWhereImGoing.y*drawConfig.pixelsPerHeight+worldTopY;
                            
                            var amountInterpolate = ticksUpdate/updateTicks; // should be animTicks-1 if we want 0 to 1 but we actually want it to be smooth and finish on start frame so this is right
                            leftX = leftX*(1-amountInterpolate) + interpolateLeftX*amountInterpolate;
                            topY = topY*(1-amountInterpolate) + interpolateTopY*amountInterpolate;
                            var rightX = leftX+drawConfig.pixelsPerWidth-1;
                            var bottomY = topY+drawConfig.pixelsPerHeight-1;
                            this.data[i][j].draw(ctx, ticks, leftX, topY, rightX, bottomY, drawConfig);
                        }
                    }
                    else 
                    {
                        var rightX = leftX+drawConfig.pixelsPerWidth-1;
                        var bottomY = topY+drawConfig.pixelsPerHeight-1;
                        this.data[i][j].draw(ctx, ticks, leftX, topY, rightX, bottomY, drawConfig);
                    }
                }
            }
            
            //// Object Dragging ////
            if (objectDragging != null) {
                var worldPos = mouseCoordsToWorldCoords(mouseX, mouseY, drawConfig);
                
                if (worldPosIsInWorld(this, worldPos)) {
                    var canShowPreview = true;
                    if (objectDragging.data != null){
                        canShowPreview = objectDragging.canPlace(this, worldPos.x, worldPos.y);
                    }
                    if (canShowPreview) {
                        var leftX = worldPos.x*drawConfig.pixelsPerWidth+worldLeftX;
                        var topY = worldPos.y*drawConfig.pixelsPerHeight+worldTopY;
                        var rightX = leftX+drawConfig.pixelsPerWidth-1;
                        var bottomY = topY+drawConfig.pixelsPerHeight-1;
                        // Draw preview of putting it there
                        // First, clear the cell
                        if (objectDragging.data == null) { // don't clear cell for copy object
                            ctx.fillStyle = "white";
                            ctx.strokeStyle = "white";
                            ctx.fillRect(leftX+outlineWidth, topY+outlineWidth, rightX-leftX-outlineWidth*2+1, bottomY-topY-outlineWidth*2+1);
                        }
                        // Then draw object, but grayed out
                        ctx.fillStyle = "gray";
                        ctx.strokeStyle = "gray";
                        ctx.lineWidth = 1;
                        objectDragging.draw(ctx, ticks, leftX, topY, rightX, bottomY, drawConfig);
                    }
                }
            
                ctx.strokeStyle = "black";
                ctx.fillStyle = "black";
                ctx.lineWidth = 1;
            
                var leftX = mouseX - drawConfig.pixelsPerWidth/2;
                var topY = mouseY - drawConfig.pixelsPerHeight/2;
                var rightX = leftX+drawConfig.pixelsPerWidth-1;
                var bottomY = topY+drawConfig.pixelsPerHeight-1;
                objectDragging.draw(ctx, ticks, leftX, topY, rightX, bottomY, drawConfig);
                
                return worldBounds;
            }
            
            
            //// Copying
            if (copying) {
                var worldPos = mouseCoordsToWorldCoords(mouseX, mouseY, drawConfig);
                var endCopyX = Math.max(Math.min(worldPos.x, this.width-1), 0);
                var endCopyY = Math.max(Math.min(worldPos.y, this.height-1), 0);
                var curStartCopyX = startCopyX;
                var curStartCopyY = startCopyY;
                
                // Sort so start is top left corner
                if (endCopyX < curStartCopyX) {
                    var tmp = endCopyX;
                    endCopyX = curStartCopyX;
                    curStartCopyX = tmp;
                }
                if (endCopyY < curStartCopyY) {
                    var tmp = endCopyY;
                    endCopyY = curStartCopyY;
                    curStartCopyY = tmp;
                }
                
                var leftX = curStartCopyX*drawConfig.pixelsPerWidth+worldLeftX;
                var topY = curStartCopyY*drawConfig.pixelsPerHeight+worldTopY;
                ctx.strokeStyle = "black";
                ctx.fillStyle = "black";
                ctx.lineWidth = 1;
                //ctx.lineWidth = outlineWidth*2+3;
                drawGrid(ctx, leftX, topY, drawConfig.pixelsPerWidth, drawConfig.pixelsPerHeight, endCopyX-curStartCopyX+1, endCopyY-curStartCopyY+1, drawConfig.outlineWidth);
                /*
                for (var x = startCopyX; x <= endCopyX; x++){
                    for (var y = startCopyY; y <= endCopyY; y++) {
                        
                        drawGrid(ctx, worldLeftX, worldTopY, drawConfig.pixelsPerWidth, drawConfig.pixelsPerHeight, this.width, this.height, drawConfig.outlineWidth);
                    }
                }
                */
                
            }
            
            
            var t1 = performance.now();
            //console.log("took:" + (t1 - t0) + " millis ");
        }
    };
    
    world.data = [];
    world.nextPos = [];
    world.history = [];
    world.paused = false;
    world.readyToUpdate = false;
    
    for (var i = 0; i < world.width; i++){
        
        var curRow = [];
        var nextPosRow = [];
        for (var j = 0; j < world.height; j++) {
            curRow.push(empty);
            nextPosRow.push({x: 0, y: 0});
        }
        world.data.push(curRow);
        world.nextPos.push(nextPosRow);
    }
    
    world.history.push(copyData(world.data));
    
    return world;
};



var startCopyX = 0, startCopyY = 0;


var mouseX = 0;
var mouseY = 0;



$(document).ready ( function(){



    var c = $("#world");
    var ctx = c[0].getContext('2d');
    worldGlobal = createWorld(64, 64, ctx);
    
    var world = worldGlobal;
    
    
   
    
    
    
    
    var CKEY = 67;
    var DKEY = 68;
    var DELKEY = 46;
    var WHITEKEY = 87;
    var BLACKKEY = 66;
    var UNDOKEY = 85;
    var REDOKEY = 82;
    var PAUSEKEY = 80;
    var STEPKEY = 83;
    var FANKEY = 70;
    var UPKEY = 38;
    var DOWNKEY = 40;
    var RIGHTKEY = 39;
    var LEFTKEY = 37;
    
    var pressingC = false;
    
    document.addEventListener('keydown', e => {
        if (e.keyCode == CKEY) {
            pressingC = true;
        }
        console.log("key code: " + e.keyCode);
        if (e.keyCode == UNDOKEY) {
            undo();
        }
        
        if (e.keyCode == REDOKEY) {
            redo();
        }
        
        if (e.keyCode == PAUSEKEY) {
            world.paused = !world.paused;
        }
        
        if (e.keyCode == STEPKEY) {
                world.update(0, true);
        }
        
        if (e.keyCode == DELKEY || e.keyCode == DKEY) {
            var worldPos = mouseCoordsToWorldCoords(mouseX, mouseY, globalDrawConfig);
            if (worldPosIsInWorld(world, worldPos)) {
                world.setAtPos(worldPos.x, worldPos.y, empty);
            }
            
            for (var i = 0; i < menu.colliders.length; i++){
                var col = menu.colliders[i];
                if (mouseX >= col.leftX && mouseX <= col.rightX && mouseY >= col.topY && mouseY <= col.bottomY){
                    menu.items.splice(menu.items.indexOf(col.item), 1);
                    // Rebuild copy items
                    copyItems = [];
                    for (var j = 0; j < menu.items.length; j++){
                        if (menu.items[j].label === "copyItem") {
                            copyItems.push(copyItemToLabelData(menu.items[j]));
                        }
                    }
                    window.localStorage.setItem("copyItems", JSON.stringify(copyItems));
                    break;
                }
            }
        }
        
        if (e.keyCode == FANKEY) {
            var worldPos = mouseCoordsToWorldCoords(mouseX, mouseY, globalDrawConfig);
            if (worldPosIsInWorld(world, worldPos)) {
                world.setAtPos(worldPos.x, worldPos.y, fan);
            }
        }
        
        if (e.keyCode == UPKEY) {
            var worldPos = mouseCoordsToWorldCoords(mouseX, mouseY, globalDrawConfig);
            if (worldPosIsInWorld(world, worldPos)) {
                world.setAtPos(worldPos.x, worldPos.y, upfan);
                e.preventDefault();// prevent scrolling
            }
        }
        
        if (e.keyCode == DOWNKEY) {
            var worldPos = mouseCoordsToWorldCoords(mouseX, mouseY, globalDrawConfig);
            if (worldPosIsInWorld(world, worldPos)) {
                world.setAtPos(worldPos.x, worldPos.y, downfan);
                e.preventDefault();// prevent scrolling
            }
        }
        
        if (e.keyCode == LEFTKEY) {
            var worldPos = mouseCoordsToWorldCoords(mouseX, mouseY, globalDrawConfig);
            if (worldPosIsInWorld(world, worldPos)) {
                world.setAtPos(worldPos.x, worldPos.y, leftfan);
                e.preventDefault(); // prevent scrolling
            }
        }
        
        if (e.keyCode == RIGHTKEY) {
            var worldPos = mouseCoordsToWorldCoords(mouseX, mouseY, globalDrawConfig);
            if (worldPosIsInWorld(world, worldPos)) {
                world.setAtPos(worldPos.x, worldPos.y, rightfan);
                e.preventDefault();// prevent scrolling
            }
        }
        
        if (e.keyCode == WHITEKEY) {
            var worldPos = mouseCoordsToWorldCoords(mouseX, mouseY, globalDrawConfig);
            if (worldPosIsInWorld(world, worldPos)) {
                world.setAtPos(worldPos.x, worldPos.y, circle);
            }
        }
        
        if (e.keyCode == BLACKKEY) {
            var worldPos = mouseCoordsToWorldCoords(mouseX, mouseY, globalDrawConfig);
            if (worldPosIsInWorld(world, worldPos)) {
                world.setAtPos(worldPos.x, worldPos.y, filledCircle);
            }
        }
    });
    document.addEventListener('keyup', e => {
        if (e.keyCode == CKEY) {
            pressingC = false;
            copying = false;
        }
    });
    
    document.getElementById("world").addEventListener('mousemove', e => {
      mouseX = e.offsetX;
      mouseY = e.offsetY;
    });
    document.getElementById("world").addEventListener('mousedown', e => {
      var x = e.offsetX;
      var y = e.offsetY;
      
      var worldPos = mouseCoordsToWorldCoords(x, y, globalDrawConfig);
      if (pressingC) {
        startCopyX = Math.max(Math.min(worldPos.x, worldGlobal.width-1), 0);
        startCopyY = Math.max(Math.min(worldPos.y, worldGlobal.height-1), 0);
        copying = true;
        return;
      }
      
      for (var i = 0; i < menu.colliders.length; i++){
        var col = menu.colliders[i];
        if (x >= col.leftX && x <= col.rightX && y >= col.topY && y <= col.bottomY){
            objectDragging = col.item;
        }
      }
      // Also try grabbing objects on the field
      if (objectDragging == null) {
        if (worldPosIsInWorld(world, worldPos)) {
          var itemAtPos = world.data[worldPos.x][worldPos.y];
          if (itemAtPos != empty) {
            // grab object
            objectDragging = itemAtPos;
            // set object there to empty
            world.setAtPos(worldPos.x, worldPos.y, empty);
          }
        }
      }
    });

    document.getElementById("world").addEventListener('mouseup', e => {
      var x = e.offsetX;
      var y = e.offsetY;
      
      var worldPos = mouseCoordsToWorldCoords(x, y, globalDrawConfig);
      if (pressingC) {
        var endCopyX = Math.max(Math.min(worldPos.x, worldGlobal.width-1), 0);
        var endCopyY = Math.max(Math.min(worldPos.y, worldGlobal.height-1), 0);
        var curStartCopyX = startCopyX;
        var curStartCopyY = startCopyY;
        
        // Sort so start is top left corner
        if (endCopyX < curStartCopyX) {
            var tmp = endCopyX;
            endCopyX = curStartCopyX;
            curStartCopyX = tmp;
        }
        if (endCopyY < curStartCopyY) {
            var tmp = endCopyY;
            endCopyY = curStartCopyY;
            curStartCopyY = tmp;
        }
        var copyItem = createCopyItem(world, curStartCopyX, curStartCopyY, endCopyX, endCopyY);
        if (copyItem != null) { // will be null if empty
            menu.items.push(copyItem);
            copyItems.push(copyItemToLabelData(copyItem));
            window.localStorage.setItem("copyItems", JSON.stringify(copyItems));
        }
        copying = false;
        return;
      }
      
      if (worldPosIsInWorld(world, worldPos)) {
        // Drag and drop item
        if (objectDragging != null) {
          if (objectDragging.data != null){
            var canPlace = objectDragging.canPlace(world, worldPos.x, worldPos.y);
            
            if (canPlace) {
                for (var x = 0; x < objectDragging.data.length; x++) {
                    for (var y = 0; y < objectDragging.data[0].length; y++){
                        var copyObject = objectDragging.data[x][y];
                        if (copyObject != empty) { // empty doesn't override
                            world.setAtPos(x+worldPos.x, y+worldPos.y, copyObject);
                        }
                    }
                }
            }
            else {
                //console.log("can't place, conflict");
            }
          }
          else{
            world.setAtPos(worldPos.x, worldPos.y, objectDragging);
          }
        }
      }
      // Reset drag and drop item
      objectDragging = null;
    });

    
    
    
    

    $(function(){
        $("a#downloadbutton").click(function() {
            console.log("trying to download");
            this.href = "data:text/plain;charset=UTF-8," + encodeURIComponent(JSON.stringify(copyItems));
        });
        
        $('#world')
        .bind('dragenter', ignoreDrag)
        .bind('dragover', ignoreDrag)
        .bind('drop', drop); 
    
        var firstTimeGoing = true;
        var ticksAnim = 0;
        var ticksUpdate = 0;
        var toggleTicks = 0;
        setInterval(function() {
            
            if (firstTimeGoing)
            {
                firstTimeGoing = false;
                // Call this once initially to make sure stuff is setup
                world.update(0, true);
            }
            ticksAnim = (ticksAnim + 1) % animTicks;
            ticksUpdate = (ticksUpdate + 1) % updateTicks;
            if (ticksUpdate % updateTicks == 0) {
                if (!world.paused) {
                    world.update(0, true);
                }
            }
            if (ticksUpdate == 0) {
                toggleTicks = (toggleTicks + 1) % 3;

            }
            
            var renderParams = menu.computeRenderParams(ctx, ticksAnim, world, globalDrawConfig);
            globalDrawConfig.renderParams = renderParams;
            world.draw(ctx, ticksAnim, ticksUpdate, renderParams, globalDrawConfig);
        }, 10);
    });
})


</script>
</head>
<body>
<canvas id="world"></canvas>
<br/><br/>
<a id='downloadbutton' href="" download="copyItems.txt">Download copy items</a><br>
(Drag and drop downloaded file onto canvas to restore)<br>
<br> Controls:<br>
Drag things around with the mouse<br>
Hold c, click and drag, then release click - copy<br>
u - undo<br>
r - redo<br>
p - pause/unpause<br>
s - step (while paused)<br>
<br>
Object shortcuts:<br>
w - white piece, can be pushed by fans<br>
b - black piece, solid wall<br>
f - fan
arrow keys - directional fans, airflow can be blocked<br>
</body>
<script>

</script>
</html>
